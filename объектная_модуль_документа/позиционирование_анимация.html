<!--Если значение объекта static - элемент находится на своем обычном месте в документе.-->
<!--Если присвоить значение объекта relative - можно использовать свойства стиля top/left для перемещения-->
<p style="text-align: center"> <!-- расположение картинки по центру -->
    <img src="cat.png" style="position: relative"> 
</p>
  <script>
    let cat = document.querySelector("img");
    let angle = Math.PI / 2;
    function animate(time, lastTime) {
      if (lastTime != null) {
        angle += (time - lastTime) * 0.001;
      }
      cat.style.top = (Math.sin(angle) * 20) + "px";
      cat.style.left = (Math.cos(angle) * 200) + "px";
      requestAnimationFrame(newTime => animate(newTime, time)); 
    }
    requestAnimationFrame(animate);
  </script>

<!--document.querySelector("img") - Получение первого элемента изображения -->

<!-- в коде для анимации введется счетчик angle для текущего угла анимации, счетчик увеличивается каждый раз
когда вызывается функция animate. Затем этот угол можно использовать для вычисления текущей позиции элемента-->

<!--Функции анимации передается текущее время в качестве аргумента. Чтобы 
обеспечить равномерное движение кошки в течение каждой миллисекунды, функция вычисляет скорость, с которой 
изменяется угол, как разность между текущим временем и временем последнего запуска функции.-->

<!--стиль top вычисляется с помощью math.sin и * на 20(вертикальный радиус нашего эллипса)
    стиль left основан на math.cos и * на 200(элипс сильно вытянут в ширину)
    Обычно стили требуют единиц измерений, в данном случае это пиксели, поэтому + "px"-->

<!--Сценарий использует функцию requestAnimationFrame, чтобы запланировать запуск функции animate всякий раз, 
когда браузер будет готов перерисовать изображение на экраце. Сама функция animate тоже вызывает requestAnimationFrame,
чтобы запланировать следующее обновление. Когда окно (или вкладка) браузера активно, обновления будут 
происходить со скоростью около 60 в секунду, что приведет к красивой анимации.  -->

